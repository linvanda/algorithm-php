<?php

/**
 * 时间复杂度 O(n^2) 的排序：冒泡、插入、选择
 */

 /**
  * 冒泡排序
  * 平均时间复杂度O(n^2)，空间复杂度O(1)(原地排序)，稳定排序（值相同的元素排序前后顺序不变）
  * 像这种涉及到元素交换的，交换次数等于数组的初始逆序度
  * 有序度：数组中有多少对有序元素，如 2,4,3 的有序度是 2 (2-4, 2-3)；
  * 满有序度：数组排好序后的有序度，等于 n(n-1)/2，上面的等于 3*2/2 = 3；
  * 逆序度：等于满有序度 - 初始有序度，上面的逆序度等于 3 - 2 = 1；
  * 冒泡、插入等排序， 需要交换元素的次数等于数组的逆序度；
  */
function bubble_sort(SplFixedArray $arr)
{
    if ($arr->count() < 2) {
        return;
    }

    $cnt = $arr->count();
    // 外层循环每执行一次，数组右侧就多一个已排序的元素
    for ($i = 0; $i < $cnt; $i++) {
        // 因为第 $j 次要跟 $j + 1 次比较，所以这里第二层循环只需要到 $cnt - $j - 1 就行了
        for ($j = 0; $j < $cnt - $i - 1; $j++) {
            if ($arr[$j] > $arr[$j + 1]) {
                // 交换位置
                $tmp = $arr[$j];
                $arr[$j] = $arr[$j + 1];
                $arr[$j + 1] = $tmp;
            }
        }
    }
}

/**
 * 插入排序
 */
function insert_sort(SplFixedArray $arr)
{
    if ($arr->count() < 2) {
        return;
    }

    $cnt = $arr->count();
    // 从第二个元素开始
    for ($i = 1; $i < $cnt; $i++) {
        // 先将当前需要处理的元素保存到临时变量中，防止被搬移过来的元素覆盖掉
        $val = $arr[$i];

        // 第二层从 $i 前面一个位置开始，逐渐往前面比较，直到找到合适的位置插入
        for ($j = $i - 1; $j >=0; $j--) {
            // 如果第 $j 个元素大于 $i 的，则将 $j 往后移，否则就讲 $val 插入到此位置
            // 因为该操作符合归纳法思想，能保证在处理第 i 个元素时，i 前面的已经是有序的
            if ($val < $arr[$j]) {
                // 元素往后移
                $arr[$j + 1] = $arr[$j];
            } else {
                break;
            }
        }

        // 将 val 放在 j + 1 的位置，注意走到这里，空位的索引比 j 要加 1
        $arr[$j + 1] = $val;
    }
}
